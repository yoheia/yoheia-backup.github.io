す## タイトル
SQLを速くするたった3つの原則　～SQLチューニングは職人芸ではなかった～

## 概要
- 職人芸と言われるSQLチューニングを体系的に整理し、初心者が最短で中上級者になるための高速道路を作りたいという想いでこの本を書きました。
- 絵で直感的にイメージをつかみ、具体例で実践方法を習得し、ケーススタディで理解度を確認し、現場ではチートシートですぐに確認できる構成になっています。
- Oracle Database のSQLチューニングについて書いていますが、考え方は他のRDBMS(だけでなくRDBMS以外のソフトウェア)でも通用します。

## 対象読者
- 初めてSQLチューニングを学ばれる方や初級者
- 経験で身に付けたSQLチューニングを理論的に整理されたい中上級者
- 現場でSQL チューニングを担当しているが、教えてもらえる人もなく、自力でどうにかしないといけない方

## 目次案
- 本書の俯瞰図
	- SQLチューニングマスターへの最短ルート
- [理論編]SQLを速くするたった3つの原則
	- SQLの速さはデータ量ではなく仕事量で決まる
	- 速くする方法は3つしかない
		- 仕事量を減らす
		- 並列化する
		- 高速化する
	- 仕事量を減らせば速くなる
		- データ構造重要
		- フルスキャンは悪ではない
		- ユニークスキャンは一定、フルスキャンは足算、結合は掛け算
	- 仕事量削減で解決しない場合は並列化と高速化
		- 並列化が効くのは単純で大きなタスク
		- 最後はデータを速いところにおく高速化
- [前提知識編]SQL実行の流れ
	- 絵で見るSQL実行の流れ
	- 統計情報は実行計画作成にどう使われるか
	- 統計情報を超えた最適化
- [実践編]SQLチューニングの流れ
	- 推測するな計測せよ
		- 実行計画からでなく時間からスタートする
	- ボトルネックを見つける
		- 何に時間がかかっているか特定する
		- 実行計画のどの操作で時間がかかっているか特定する
	- ボトルネックを取り除く
		- アプローチ
			- 仕事量を減らす
			- 並列化
			- 高速化
		- 手段
			- 統計情報を収集する
			- SQLを書換える
			- データ構造を変える
			- ヒントなどで人為的に実行計画を操作する
	- チューニング結果を評価する
		- 実行時間と仕事量で評価する
		- データ量増加時の性能劣化を考慮する
- [実践編]ボトルネックを特定する
	- 実行時間の内訳を見る(DB Time + AP Time + N/W Time)
	- DB Time の内訳を見る(CPU Time + I/O Wait + ...)
	- I/O Wait = direct path read + ...
	- どの処理で時間がかかっているか特定する(実行計画のどの操作か)
- [実践編]ボトルネックを取り除く
	- 仕事量を減らす
		- 行方向で絞る
			- インデックス(索引)
			- パーティショニング(電話帳)
			- 結合順・結合方法(掛算に注意)
		- 列方向で絞る
			- カバリング・インデックス
			- DBIM
			- 圧縮
		- 再利用・省略
			- 索引によるソート省略
			- コネクションプーリング(接続再利用)
			- バインド変数(ハードパース省略)
			- セッション・カーソル・キャッシュ(ソフトパース省略)
			- フェッチ・サイズを大きくしてラウンドトップ回数を減らす
			- バルク処理でまとめる
	- 並列化する
		- パラレルクエリー・DML
	- 高速化する
		- 速い所にデータを置く
			- KEEP Buffer(表・索引・カバリングインデックス)
			- DBIM
			- フラッシュにデータをおく
- [ケーススタディ(20問)

### コラム
- これだけは押さえておこう待ち行列理論
- 知って損はない USE メソッド
- アムダールの当たり前な法則
- RDBMSとクエリーオプティマイザの歴史(実は珍しいルールベース)
- Oracle Database が流行った理由(マルチプロセス、ルールベース、MVCC、RAC)
- Oracle Database の性能分析メソッドの歴史
- 知ってるつもり？レスポンスとスループット
- プロセスの状態遷移が分かると待機イベントが分かる
- 実行計画のオペレーションは関数名と一致する
- sort するとなぜ consistent gets が減るか
- V$SQL_HINT で使えるヒントを調べる
- Exadata は魔法のように速い理由
- Oracle Database In Memory のコンセプト


### Appendix(チートシート)
- コンピュータのキャッシュ階層とレイテンシ
- 実行計画の取得方法
- 実行計画の読み方
- 実行計画の種類
- 統計情報の種類と収集方法
- ヒント句の種類
- ハマりやすい制限値一覧
- 突然SQL性能劣化時の原因切り分けチェックシート

### 参考書籍

### ケーススタディ
- <http://app.m-cocolog.jp/t/typecast/121907/106341/68994334>
	- パーティション選択ミス
	- ファンクション索引
	- 複合索引の列順
	- ローカル索引
	- WITH句でまとめる
	- CUBE
- <http://app.m-cocolog.jp/t/typecast/121907/106341/84809731>
	- NULL許容列の単一列索引は IS NOT NULL の検索に使われる
	- NOT NULL列を含む複合索引は IS NULL の検索に使われる
- <http://app.m-cocolog.jp/t/typecast/121907/106341/61558002>
	- ユニーク制約に非ユニーク索引をつかえる
	- 制約作成時に明示指定しなくても使える索引があると自動的使われる
	- 一意制約のチェックには最低 INDEX RANGE SCAN 出来る必要がある？
- <http://app.m-cocolog.jp/t/typecast/121907/106341/69545127>
	- ハードパースが遅い
	- SQLトレースが有効
